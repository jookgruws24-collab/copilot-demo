# Data Model: Employee Achievement and Rewards System

**Feature**: Employee Achievement and Rewards System  
**Date**: 2025-11-10  
**Database**: SQLite 3  
**Driver**: better-sqlite3

---

## Entity Relationship Diagram

```
                    employees (1) ----< (*) achievement_progress
                        |                        |
                        |                        |
                        |                   achievements (1)
                        |
invitation_codes (1) -->|
                        |
                        |---- (1) sessions (*)
                        |
                        |---- (1) purchases (*) ----< (1) products
                        |
                        |---- (1) history (*)
```

**Legend**:
- `(1)` = one
- `(*)` = many
- `----<` = one-to-many relationship
- `-->` = optional reference (invitation code may be used by employee)

---

## Tables

### 1. employees

Stores employee profiles with authentication and role information.

```sql
CREATE TABLE employees (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id TEXT NOT NULL UNIQUE,     -- Business identifier (e.g., "EMP001")
  name TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,          -- bcryptjs hash
  contact TEXT NOT NULL,                -- Phone number
  address TEXT NOT NULL,                -- Physical address
  role TEXT NOT NULL DEFAULT 'user',    -- 'user', 'admin', or 'hr'
  diamond_balance INTEGER NOT NULL DEFAULT 0,
  invitation_code_used TEXT,            -- Code used during registration (optional)
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  CHECK (role IN ('user', 'admin', 'hr')),
  CHECK (diamond_balance >= 0)
);

CREATE INDEX idx_employees_email ON employees(email);
CREATE INDEX idx_employees_employee_id ON employees(employee_id);
CREATE INDEX idx_employees_role ON employees(role);
CREATE INDEX idx_employees_invitation_code ON employees(invitation_code_used);
```

**Constraints**:
- `employee_id`: Unique business identifier (FR-006)
- `email`: Unique for authentication
- `role`: Enum constraint (user, admin, hr) (FR-003)
- `diamond_balance`: Cannot be negative (FR-039)

**Notes**:
- `password_hash` stores bcryptjs output (never plain text)
- `created_at`, `updated_at` use ISO 8601 format
- Balance stored directly on employee (no separate table needed)

---

### 2. invitation_codes

Stores invitation codes generated by Admin/HR for employee registration.

```sql
CREATE TABLE invitation_codes (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT NOT NULL UNIQUE,            -- Random 8-char alphanumeric (e.g., "AB3X9K2M")
  label TEXT,                           -- Optional label (e.g., "Q1 2025 Hires")
  created_by INTEGER NOT NULL,          -- Admin/HR who created it
  is_active INTEGER NOT NULL DEFAULT 1, -- 0 = deactivated, 1 = active
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (created_by) REFERENCES employees(id),
  CHECK (is_active IN (0, 1))
);

CREATE INDEX idx_invitation_codes_code ON invitation_codes(code);
CREATE INDEX idx_invitation_codes_active ON invitation_codes(is_active);
CREATE INDEX idx_invitation_codes_created_by ON invitation_codes(created_by);
```

**Purpose**: Enable Admin/HR to generate and manage invitation codes for tracking registration sources.

**Constraints**:
- `code`: Unique 8-character alphanumeric string
- `label`: Optional description for organizational purposes
- `is_active`: Allows deactivation without deletion (preserves audit trail)

**Code Generation**: Random alphanumeric using characters A-Z, a-z, 0-9 (excluding ambiguous: 0, O, 1, I, l)

**Notes**:
- Codes never expire (per FR-005) but can be deactivated via `is_active`
- Codes can be reused multiple times (no usage limit)
- Usage tracked via `invitation_code_used` field in `employees` table

---

### 3. sessions

Stores active authentication sessions.

```sql
CREATE TABLE sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER NOT NULL,
  token TEXT NOT NULL UNIQUE,           -- Random session token
  expires_at TEXT NOT NULL,             -- ISO 8601 timestamp
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE CASCADE
);

CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_employee ON sessions(employee_id);
CREATE INDEX idx_sessions_expires ON sessions(expires_at);
```

**Purpose**: Track active sessions for authentication and logout.

**Constraints**:
- `token`: Unique session identifier (stored in HTTP-only cookie)
- Foreign key cascade: Delete sessions when employee deleted

**Cleanup Strategy**: Periodic job to delete expired sessions (WHERE expires_at < now())

---

### 4. achievements

Stores achievement definitions created by Admin/HR.

```sql
CREATE TABLE achievements (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  conditions TEXT NOT NULL,             -- Human-readable conditions
  diamond_reward INTEGER NOT NULL,
  start_date TEXT NOT NULL,             -- ISO 8601 date
  end_date TEXT NOT NULL,               -- ISO 8601 date
  created_by INTEGER NOT NULL,          -- Admin/HR who created it
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (created_by) REFERENCES employees(id),
  CHECK (diamond_reward > 0),
  CHECK (end_date > start_date)
);

CREATE INDEX idx_achievements_dates ON achievements(start_date, end_date);
CREATE INDEX idx_achievements_created_by ON achievements(created_by);
```

**Constraints**:
- `diamond_reward`: Must be positive
- `end_date`: Must be after `start_date`
- Foreign key to track which admin/HR created the achievement

**State Determination** (computed at query time):
- **Upcoming**: `date('now') < start_date`
- **On Doing**: `start_date <= date('now') AND date('now') <= end_date`
- **Expired**: `date('now') > end_date`

---

### 5. achievement_progress

Tracks each employee's progress toward achievements.

```sql
CREATE TABLE achievement_progress (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER NOT NULL,
  achievement_id INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'on_doing',  -- 'upcoming', 'on_doing', 'completed', 'claimed'
  progress_percentage INTEGER NOT NULL DEFAULT 0,
  claimed_at TEXT,                           -- NULL until claimed
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE CASCADE,
  FOREIGN KEY (achievement_id) REFERENCES achievements(id) ON DELETE CASCADE,
  CHECK (status IN ('upcoming', 'on_doing', 'completed', 'claimed')),
  CHECK (progress_percentage >= 0 AND progress_percentage <= 100),
  UNIQUE(employee_id, achievement_id)       -- One progress record per employee per achievement
);

CREATE INDEX idx_progress_employee ON achievement_progress(employee_id);
CREATE INDEX idx_progress_achievement ON achievement_progress(achievement_id);
CREATE INDEX idx_progress_status ON achievement_progress(employee_id, status);
```

**Constraints**:
- `status`: Enum (upcoming, on_doing, completed, claimed)
- `progress_percentage`: 0-100
- Unique constraint prevents duplicate progress records (FR-015)

**State Transitions**:
1. **upcoming** → **on_doing**: When achievement start_date reached
2. **on_doing** → **completed**: When progress reaches 100%
3. **completed** → **claimed**: When employee clicks "Claim" button (FR-013)

**Notes**:
- `claimed_at` is NULL until claim action (distinguishes completed vs. claimed)
- Progress can be updated manually by Admin/HR or automatically based on system events

---

### 6. products

Stores product catalog for the rewards store.

```sql
CREATE TABLE products (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  diamond_price INTEGER NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 0,
  image_url TEXT,                        -- Optional product image
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  CHECK (diamond_price > 0),
  CHECK (quantity >= 0)
);

CREATE INDEX idx_products_price ON products(diamond_price);
```

**Constraints**:
- `diamond_price`: Must be positive
- `quantity`: Cannot be negative (FR-022)

**Availability Logic**:
- Product available if `quantity > 0`
- Purchase decrements quantity (within transaction)

---

### 7. purchases

Stores all product purchase requests and their approval status.

```sql
CREATE TABLE purchases (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER NOT NULL,
  product_id INTEGER NOT NULL,
  product_name TEXT NOT NULL,            -- Denormalized for history (FR-036)
  diamond_cost INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
  rejection_reason TEXT,                  -- NULL unless rejected
  approved_by INTEGER,                    -- Admin who approved/rejected
  approved_at TEXT,                       -- NULL until processed
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (employee_id) REFERENCES employees(id),
  FOREIGN KEY (product_id) REFERENCES products(id),
  FOREIGN KEY (approved_by) REFERENCES employees(id),
  CHECK (status IN ('pending', 'accepted', 'rejected')),
  CHECK (diamond_cost > 0)
);

CREATE INDEX idx_purchases_employee ON purchases(employee_id);
CREATE INDEX idx_purchases_status ON purchases(status, created_at DESC);
CREATE INDEX idx_purchases_approved_by ON purchases(approved_by);
```

**Constraints**:
- `status`: Enum (pending, accepted, rejected)
- `diamond_cost`: Must be positive
- `product_name`: Denormalized to preserve history if product deleted (FR-036)

**Workflow**:
1. **Create**: Employee initiates purchase → status = 'pending', balance deducted (FR-019)
2. **Approve**: Admin approves → status = 'accepted', approved_by/approved_at set (FR-024)
3. **Reject**: Admin rejects → status = 'rejected', balance refunded, rejection_reason set (FR-025, FR-026)

**Notes**:
- Balance deducted at creation time (optimistic, refunded if rejected)
- `approved_by` and `approved_at` track admin for audit (FR-028)

---

### 8. history

Immutable audit log of all achievement claims and product purchases.

```sql
CREATE TABLE history (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER NOT NULL,
  employee_name TEXT NOT NULL,           -- Denormalized for anonymization
  type TEXT NOT NULL,                    -- 'claim' or 'purchase'
  action TEXT NOT NULL,                  -- 'created', 'approved', 'rejected', 'claimed'
  details TEXT NOT NULL,                 -- JSON with achievement/product info
  diamonds INTEGER NOT NULL,             -- Positive for claims, negative for purchases
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE SET NULL,
  CHECK (type IN ('claim', 'purchase')),
  CHECK (action IN ('created', 'approved', 'rejected', 'claimed'))
);

CREATE INDEX idx_history_employee ON history(employee_id, created_at DESC);
CREATE INDEX idx_history_type ON history(type, created_at DESC);
CREATE INDEX idx_history_created_at ON history(created_at DESC);
CREATE INDEX idx_history_search ON history(employee_name, details);
```

**Constraints**:
- `type`: Enum (claim, purchase)
- `action`: Enum (created, approved, rejected, claimed)
- Foreign key with `ON DELETE SET NULL`: Preserve history if employee deleted (FR-036)

**Details JSON Structure**:

```json
// Claim
{
  "achievement_id": 1,
  "achievement_title": "Complete 10 Tasks",
  "diamonds_earned": 50
}

// Purchase
{
  "purchase_id": 5,
  "product_id": 3,
  "product_name": "Coffee Mug",
  "diamond_cost": 25,
  "status": "accepted",
  "approved_by": "Jane Admin"
}
```

**Notes**:
- `employee_name` denormalized for search after employee deletion (anonymization)
- `details` as JSON preserves full context even if achievement/product deleted (FR-036)
- `diamonds` positive for earnings (claims), negative for spending (purchases)

---

## Relationships

### employees → invitation_codes (N:1)
- Many employees may use the same invitation code
- No foreign key constraint: Code stored as text for audit, code can be deleted without affecting employees

### invitation_codes → employees (1:N)
- One invitation code can be used by many employees (via `created_by`)
- One Admin/HR creates many invitation codes
- No cascade: Preserve creator reference even if creator deleted

### employees → achievement_progress (1:N)
- One employee can have progress on many achievements
- Cascade delete: Progress deleted if employee deleted

### achievements → achievement_progress (1:N)
- One achievement tracked by many employees
- Cascade delete: Progress deleted if achievement deleted

### employees → purchases (1:N)
- One employee can make many purchases
- No cascade: Preserve purchase history if employee deleted

### products → purchases (1:N)
- One product can be purchased many times
- No cascade: Preserve purchase history if product deleted

### employees → history (1:N)
- One employee generates many history entries
- `ON DELETE SET NULL`: Preserve history, anonymize if employee deleted

### employees → sessions (1:N)
- One employee can have multiple active sessions
- Cascade delete: Remove sessions if employee deleted

---

## Indexes Summary

Performance-critical indexes for query optimization:

| Table | Index | Purpose |
|-------|-------|---------|
| employees | email, employee_id, invitation_code_used | Authentication, profile lookup, code audit |
| invitation_codes | code, is_active, created_by | Code validation, admin management |
| sessions | token, expires_at | Session validation, cleanup |
| achievements | (start_date, end_date) | Status determination (upcoming/active/expired) |
| achievement_progress | (employee_id, status) | Filter by employee + status (FR-014) |
| purchases | (status, created_at DESC) | Admin approval queue (FR-027) |
| history | (employee_id, created_at), (type, created_at), (employee_name, details) | Personal history, filtering, search (FR-038, FR-039) |

**Rationale**: Composite indexes optimize filtered queries (SC-010: <2s for 10k records).

---

## Data Integrity Rules

### Transaction Boundaries

**Achievement Claim** (FR-013, FR-014):
```sql
BEGIN TRANSACTION;
  UPDATE employees SET diamond_balance = diamond_balance + ? WHERE id = ?;
  UPDATE achievement_progress SET status = 'claimed', claimed_at = datetime('now') WHERE id = ?;
  INSERT INTO history (...) VALUES (...);
COMMIT;
```

**Purchase Creation** (FR-019, FR-020):
```sql
BEGIN TRANSACTION;
  SELECT balance FROM employees WHERE id = ? FOR UPDATE; -- Lock row
  -- Check balance >= cost
  UPDATE employees SET diamond_balance = diamond_balance - ? WHERE id = ?;
  UPDATE products SET quantity = quantity - 1 WHERE id = ?;
  INSERT INTO purchases (...) VALUES (...);
  INSERT INTO history (...) VALUES (...);
COMMIT;
```

**Purchase Rejection** (FR-026):
```sql
BEGIN TRANSACTION;
  UPDATE employees SET diamond_balance = diamond_balance + ? WHERE id = ?;
  UPDATE purchases SET status = 'rejected', rejection_reason = ?, approved_by = ?, approved_at = datetime('now') WHERE id = ?;
  INSERT INTO history (...) VALUES (...);
COMMIT;
```

### Consistency Rules

1. **Balance Accuracy** (FR-038, SC-007):
   - Balance changes only within transactions
   - Every balance change has corresponding history entry
   - Periodic audit: `SUM(history.diamonds) WHERE employee_id = X` should equal `employees.diamond_balance`

2. **No Negative Balances** (FR-039):
   - CHECK constraint on `employees.diamond_balance >= 0`
   - Explicit balance check before purchase creation

3. **No Duplicate Claims** (FR-015):
   - UNIQUE constraint on `(employee_id, achievement_id)` in `achievement_progress`
   - Status check: Cannot claim if already 'claimed'

4. **Expired Achievements** (FR-011):
   - Application-level check: `WHERE date('now') <= end_date` before allowing claim

---

## Sample Queries

### Generate New Invitation Code
```sql
-- Generate unique 8-character code
INSERT INTO invitation_codes (code, label, created_by)
VALUES (?, ?, ?);

-- Example with label
INSERT INTO invitation_codes (code, label, created_by)
VALUES ('AB3X9K2M', 'Q1 2025 Engineering Hires', 1);
```

### Validate Invitation Code
```sql
SELECT id, code, label, is_active
FROM invitation_codes
WHERE code = ? AND is_active = 1;
```

### List All Invitation Codes with Usage Stats
```sql
SELECT 
  ic.id,
  ic.code,
  ic.label,
  ic.is_active,
  ic.created_at,
  e_creator.name as created_by_name,
  COUNT(e_users.id) as usage_count
FROM invitation_codes ic
LEFT JOIN employees e_creator ON e_creator.id = ic.created_by
LEFT JOIN employees e_users ON e_users.invitation_code_used = ic.code
GROUP BY ic.id
ORDER BY ic.created_at DESC;
```

### Deactivate Invitation Code
```sql
UPDATE invitation_codes
SET is_active = 0
WHERE code = ?;
```

### Get Employees by Invitation Code
```sql
SELECT 
  employee_id,
  name,
  email,
  role,
  created_at
FROM employees
WHERE invitation_code_used = ?
ORDER BY created_at DESC;
```

### Get Employee's Active Achievements
```sql
SELECT 
  a.id,
  a.title,
  a.diamond_reward,
  ap.progress_percentage,
  ap.status,
  CASE
    WHEN date('now') < a.start_date THEN 'upcoming'
    WHEN date('now') > a.end_date THEN 'expired'
    ELSE 'active'
  END as achievement_status
FROM achievements a
LEFT JOIN achievement_progress ap ON ap.achievement_id = a.id AND ap.employee_id = ?
WHERE date('now') <= a.end_date
ORDER BY a.start_date ASC;
```

### Admin Approval Queue (Pending Purchases)
```sql
SELECT 
  p.id,
  p.product_name,
  p.diamond_cost,
  p.created_at,
  e.name as employee_name,
  e.employee_id
FROM purchases p
JOIN employees e ON e.id = p.employee_id
WHERE p.status = 'pending'
ORDER BY p.created_at ASC;
```

### History with Filters (Admin View)
```sql
SELECT 
  h.id,
  h.employee_name,
  h.type,
  h.action,
  h.diamonds,
  h.details,
  h.created_at
FROM history h
WHERE 
  (? IS NULL OR h.employee_id = ?)           -- Filter by employee
  AND (? IS NULL OR h.type = ?)              -- Filter by type
  AND (? IS NULL OR date(h.created_at) >= ?) -- Date range start
  AND (? IS NULL OR date(h.created_at) <= ?) -- Date range end
  AND (? IS NULL OR h.employee_name LIKE ? OR h.details LIKE ?) -- Search
ORDER BY h.created_at DESC
LIMIT ? OFFSET ?;
```

### Check Purchase Eligibility
```sql
SELECT 
  e.diamond_balance,
  p.diamond_price,
  p.quantity,
  CASE
    WHEN e.diamond_balance < p.diamond_price THEN 'insufficient_balance'
    WHEN p.quantity = 0 THEN 'out_of_stock'
    ELSE 'eligible'
  END as status
FROM employees e
CROSS JOIN products p
WHERE e.id = ? AND p.id = ?;
```

---

## Migration Plan

### Initial Schema (Migration 001)

File: `lib/db/migrations/001_initial_schema.sql`

```sql
-- Enable foreign keys
PRAGMA foreign_keys = ON;

-- Create all tables
CREATE TABLE employees (...);
CREATE TABLE invitation_codes (...);
CREATE TABLE sessions (...);
CREATE TABLE achievements (...);
CREATE TABLE achievement_progress (...);
CREATE TABLE products (...);
CREATE TABLE purchases (...);
CREATE TABLE history (...);

-- Create all indexes
CREATE INDEX ...;

-- Schema version tracking
CREATE TABLE schema_version (
  version INTEGER PRIMARY KEY,
  applied_at TEXT NOT NULL DEFAULT (datetime('now'))
);

INSERT INTO schema_version (version) VALUES (1);
```

### Migration Runner

```typescript
// lib/db/client.ts
import Database from 'better-sqlite3'
import fs from 'fs'

const db = new Database('lib/db/copilot-demo.db')
db.pragma('foreign_keys = ON')

function runMigrations() {
  const currentVersion = db.prepare('SELECT MAX(version) as v FROM schema_version').get()?.v || 0
  const migrations = fs.readdirSync('lib/db/migrations').sort()
  
  for (const file of migrations) {
    const version = parseInt(file.split('_')[0])
    if (version > currentVersion) {
      const sql = fs.readFileSync(`lib/db/migrations/${file}`, 'utf-8')
      db.exec(sql)
      console.log(`Applied migration ${file}`)
    }
  }
}

runMigrations()
export default db
```

---

## Next Steps

1. ✅ **COMPLETE**: Data model defined with full schema
2. **TODO**: Generate API contracts (OpenAPI specs for all endpoints)
3. **TODO**: Create quickstart.md with seed data script
4. **TODO**: Implement schema migration runner in `lib/db/client.ts`
5. **TODO**: Generate TypeScript types from schema

**Status**: Phase 1 - Data model complete, ready for API contract design
